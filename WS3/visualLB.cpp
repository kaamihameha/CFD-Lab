#include <list>
#include <iostream>
#include <string>
#include <stdio.h>
#include <math.h>

#include "helper.h"
#include "visualLB.h"
#include "computeCellValues.h"
#include "LBDefinitions.h"
#include "DataStructure.h"



//Writes Density and Velocity from the collision field
void writeVtkOutput( const char * filename,
                     double * const collideField,
                     std::list<Fluid*>& FluidDomain,
                     std::list<Fluid*>& VTKrepresentation,
                     int *IdField,
                     unsigned int t,
                     unsigned* Length ) {


    char szFilename[80];
    FILE *fp = NULL;
    sprintf( szFilename, "%s.%i.vtk", filename, t );

    fp = fopen( szFilename, "w");
    if( fp == NULL ) {
        char szBuff[80];
        sprintf( szBuff, "Failed to open %s", filename );
        ERROR(szBuff);
        return;
    }

//------------------------------------------------------------------------------
//                   Write the file header and coordinates
//------------------------------------------------------------------------------

    write_vtkHeader( fp, FluidDomain, Length );

    write_vtkPointCoordinates( fp, FluidDomain, Length );
//------------------------------------------------------------------------------
//                   Write the file header and coordinates
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////

    write_vtkPointElements( fp, VTKrepresentation, IdField, Length );



////////////////////////////////////////////////////////////////////////////////
    fprintf(fp, "\nPOINT_DATA %lu \n", FluidDomain.size() );



//------------------------------------------------------------------------------
//                        Write density to the file
//------------------------------------------------------------------------------
    //Computing Density
    fprintf(fp, "SCALARS density float 1 \n");
    fprintf(fp, "LOOKUP_TABLE default \n");
    double Density = 0.0;

    // DEBUGGING: chech computeDensity

#ifdef DEBUGGING
    const double MAXIMUM_DENSITY = 1.1;
    const double MINIMUM_DENSITY = 0.9;
#endif


    double* Index = 0;
    for ( std::list<Fluid*>::iterator Iterator = FluidDomain.begin();
          Iterator != FluidDomain.end();
          ++Iterator ) {

                Index = collideField + (*Iterator)->getIndex( SELF_INDEX );
                computeDensity ( Index, &Density );

                fprintf( fp, "%f\n", Density );

#ifdef DEBUGGING
        if( ( Density < MINIMUM_DENSITY ) || ( Density > MAXIMUM_DENSITY ) )
        printf("x %d y %d z %d  %f   \n", (*Iterator)->getXCoord(),
                                          (*Iterator)->getYCoord(),
                                          (*Iterator)->getZCoord(),
                                          Density);
#endif

    }

//------------------------------------------------------------------------------
//                        Write velocity to the file
//------------------------------------------------------------------------------
    //Computing Velocity
    fprintf(fp, "\nVECTORS velocity float \n");
    double Velocity[ 3 ] = { 0.0 };
    Index = 0;
    for ( std::list<Fluid*>::iterator aFluidCell = FluidDomain.begin();
          aFluidCell != FluidDomain.end();
          ++aFluidCell ) {

				Index = collideField + (*aFluidCell)->getIndex( SELF_INDEX );

                computeDensity ( Index, &Density );
                computeVelocity ( Index, &Density, Velocity );


                fprintf(fp, "%f %f %f\n", Velocity [0], Velocity [1], Velocity [2]);
    }
    fclose(fp);

}


void write_vtkHeader( FILE *fp,
                      std::list<Fluid*>& FluidDomain,
                      unsigned* Length ) {

    if( fp == NULL )
    {
        char szBuff[80];
        sprintf( szBuff, "Null pointer in write_vtkHeader" );
        ERROR( szBuff );
        return;
    }

    fprintf(fp,"# vtk DataFile Version 2.0\n");
    fprintf(fp,"generated by CFD-lab course output \n");
    fprintf(fp,"ASCII\n");
    fprintf(fp,"\n");
    fprintf(fp,"DATASET UNSTRUCTURED_GRID\n");
    fprintf(fp,"POINTS %d float\n", (int)FluidDomain.size() );
    fprintf(fp,"\n");

}


void write_vtkPointCoordinates( FILE* fp,
                                std::list<Fluid*>& FluidDomain,
                                unsigned* Length ) {

    for ( std::list<Fluid*>::iterator Iterator = FluidDomain.begin();
          Iterator != FluidDomain.end();
          ++Iterator ) {

              fprintf(fp, "%d %d %d\n", (*Iterator)->getXCoord(),
                                        (*Iterator)->getYCoord(),
                                        (*Iterator)->getZCoord() );
          }


}


void write_vtkPointElements( FILE* fp,
                             std::list<Fluid*>& VTKrepresentation,
                             int* IdField,
                             unsigned* Length ) {
    // see the documentation: http://www.vtk.org/data-model/
    const char CODE_OF_ELEMENT[] = "11";
    const unsigned NUMBER_OF_POINT_PER_ELEMENT = 8;
    unsigned nElements = VTKrepresentation.size();
    unsigned nEntries = ( NUMBER_OF_POINT_PER_ELEMENT + 1 ) * ( nElements );


    char Buffer[ 50 ];
    std::string DELIMITER = " ";
    std::string Line = "";
    int DiagonalNeighborIndex = 0;

    // Print all elements
    fprintf(fp,"\nCELLS %u %u\n", nElements, nEntries );
    for ( std::list<Fluid*>::iterator Element = VTKrepresentation.begin();
          Element != VTKrepresentation.end();
          ++Element ) {

              // Print number entries that a line contains
              sprintf( Buffer, "%u", NUMBER_OF_POINT_PER_ELEMENT );
              Line = Buffer + DELIMITER;

              // walk aroun in the cell's neighbor according to VTL_VOXEL = 11
              // see the documentation: http://www.vtk.org/data-model/
              // Vertex 0:
              sprintf( Buffer, "%d",
                       IdField[ (*Element)->getIdIndex( 9 ) ] );
              Line += Buffer + DELIMITER;

              // Vertex 1:
              sprintf( Buffer, "%d",
                       IdField[ (*Element)->getIdIndex( 10 ) ] );
              Line += Buffer + DELIMITER;

              // Vertex 2:
              sprintf( Buffer, "%d",
                       IdField[ (*Element)->getIdIndex( 12 ) ] );
              Line += Buffer + DELIMITER;

              // Vertex 3:
              sprintf( Buffer, "%d",
                       IdField[ (*Element)->getIdIndex( 13 ) ] );
              Line += Buffer + DELIMITER;

              // Vertex 4:
              sprintf( Buffer, "%d",
                       IdField[ (*Element)->getIdIndex( 16 ) ] );
              Line += Buffer + DELIMITER;

              // Vertex 5:
              sprintf( Buffer, "%d",
                       IdField[ (*Element)->getIdIndex( 17 ) ] );
              Line += Buffer + DELIMITER;

              // Vertex 6:
              sprintf( Buffer, "%d",
                       IdField[ (*Element)->getIdIndex( 18 ) ] );
              Line += Buffer + DELIMITER;

              // Vertex 7:
              // Because of the D3Q19 scheme there is no diagonal neighbours
              // we have to compute it explicitly

              DiagonalNeighborIndex = computeFlagIndex( (*Element)->getXCoord() + 1,
                                                        (*Element)->getYCoord() + 1,
                                                        (*Element)->getZCoord() + 1,
                                                        Length );

              sprintf( Buffer, "%d", IdField[ DiagonalNeighborIndex ] );
              Line += Buffer;

              // Print given line to the file
              fprintf(fp, "%s\n", Line.c_str());
    }

    // Print type of the elements
    fprintf(fp,"\nCELL_TYPES %u\n", nElements );
    for ( std::list<Fluid*>::iterator Element = VTKrepresentation.begin();
          Element != VTKrepresentation.end();
          ++Element ) {

            fprintf(fp, "%s\n", CODE_OF_ELEMENT );

    }
}
